pub mod proto {
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub mod prover;
}
pub mod client;
mod io;
mod util;
pub mod utils {
    pub use wp1_core::utils::{
        setup_logger, setup_tracer, BabyBearBlake3, BabyBearKeccak, BabyBearPoseidon2,
    };
}
pub use crate::io::*;
use proto::prover::ProofStatus;
use utils::*;

use crate::client::SP1ProverServiceClient;
use anyhow::{Ok, Result};
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};
use std::fs;
use std::time::Duration;
use tokio::time::sleep;
use util::StageProgressBar;
use wp1_core::runtime::{Program, Runtime};
use wp1_core::stark::{Com, PcsProverData, RiscvAir};
use wp1_core::stark::{
    OpeningProof, ProgramVerificationError, Proof, ShardMainData, StarkGenericConfig,
};
use wp1_core::utils::run_and_prove;

/// A prover that can prove RISCV ELFs.
pub struct SP1Prover;

/// A verifier that can verify proofs generated by `SP1Prover`.
pub struct SP1Verifier;

/// A proof of a RISCV ELF execution with given inputs and outputs.
#[derive(Serialize, Deserialize)]
pub struct SP1ProofWithIO<SC: StarkGenericConfig + Serialize + DeserializeOwned> {
    #[serde(with = "proof_serde")]
    pub proof: Proof<SC>,
    pub stdin: SP1Stdin,
    pub stdout: SP1Stdout,
}

impl SP1Prover {
    /// Executes the elf with the given inputs and returns the output.
    pub fn execute(elf: &[u8], stdin: SP1Stdin) -> Result<SP1Stdout> {
        let program = Program::from(elf);
        let mut runtime = Runtime::new(program);
        runtime.write_stdin_slice(&stdin.buffer.data);
        runtime.run();
        Ok(SP1Stdout::from(&runtime.state.output_stream))
    }

    /// Generate a proof for the execution of the ELF with the given public inputs.
    pub fn prove(elf: &[u8], stdin: SP1Stdin) -> Result<SP1ProofWithIO<BabyBearPoseidon2>> {
        Self::prove_with_config(elf, stdin, BabyBearPoseidon2::new())
    }

    async fn prove_remote<SC: StarkGenericConfig>(
        elf: &[u8],
        stdin: SP1Stdin,
    ) -> Result<SP1ProofWithIO<SC>>
    where
        SC: StarkGenericConfig,
        SC::Challenger: Clone,
        OpeningProof<SC>: Send + Sync,
        Com<SC>: Send + Sync,
        PcsProverData<SC>: Send + Sync,
        ShardMainData<SC>: Serialize + DeserializeOwned,
        SC::Val: p3_field::PrimeField32,
    {
        let access_token = std::env::var("PROVER_NETWORK_ACCESS_TOKEN").unwrap();
        let client = SP1ProverServiceClient::with_token(access_token);
        let id = client.create_proof(elf, &stdin.buffer.data).await?;

        let mut pb = StageProgressBar::new();
        loop {
            let status = client.get_proof_status(&id).await;
            match status {
                std::result::Result::Ok(status) => {
                    if status.0.status() == ProofStatus::Failed {
                        pb.finish();
                        return Err(anyhow::anyhow!("Proof failed"));
                    }
                    if let Some(result) = status.1 {
                        println!("Proof succeeded\n\n");
                        pb.finish();
                        return Ok(result);
                    }
                    pb.update(
                        status.0.stage,
                        status.0.total_stages,
                        &status.0.stage_name,
                        status.0.stage_progress.map(|p| (p, status.0.stage_total())),
                    );
                }
                Err(e) => {
                    pb.finish();
                    return Err(e);
                }
            }
            sleep(Duration::from_secs(1)).await;
        }
    }

    /// Generate a proof for the execution of the ELF with the given public inputs and a custom config.
    pub fn prove_with_config<SC: StarkGenericConfig>(
        elf: &[u8],
        stdin: SP1Stdin,
        config: SC,
    ) -> Result<SP1ProofWithIO<SC>>
    where
        SC: StarkGenericConfig,
        SC::Challenger: Clone,
        OpeningProof<SC>: Send + Sync,
        Com<SC>: Send + Sync,
        PcsProverData<SC>: Send + Sync,
        ShardMainData<SC>: Serialize + DeserializeOwned,
        SC::Val: p3_field::PrimeField32,
    {
        if std::env::var("PROVER_NETWORK_ACCESS_TOKEN").is_ok() {
            log::info!("PROVER_NETWORK_ACCESS_TOKEN is set, proving remotely");
            match tokio::runtime::Handle::try_current() {
                std::result::Result::Ok(handle) => {
                    tokio::task::block_in_place(|| handle.block_on(Self::prove_remote(elf, stdin)))
                }
                Err(_) => {
                    // Handle case where there is no current Tokio runtime
                    let rt = tokio::runtime::Runtime::new()
                        .expect("Failed to create a new Tokio runtime");
                    rt.handle().block_on(Self::prove_remote(elf, stdin))
                }
            }
        } else {
            let program = Program::from(elf);
            let (proof, stdout_vec) = run_and_prove(&program, &stdin.buffer.data, config);
            let stdout = SP1Stdout::from(&stdout_vec);
            Ok(SP1ProofWithIO {
                proof,
                stdin,
                stdout,
            })
        }
    }
}

impl SP1Verifier {
    /// Verify a proof generated by `SP1Prover`.
    #[allow(unused_variables)]
    pub fn verify(
        elf: &[u8],
        proof: &SP1ProofWithIO<BabyBearPoseidon2>,
    ) -> Result<(), ProgramVerificationError> {
        Self::verify_with_config(elf, proof, BabyBearPoseidon2::new())
    }

    /// Verify a proof generated by `SP1Prover` with a custom config.
    #[allow(unused_variables)]
    pub fn verify_with_config<SC: StarkGenericConfig>(
        elf: &[u8],
        proof: &SP1ProofWithIO<SC>,
        config: SC,
    ) -> Result<(), ProgramVerificationError>
    where
        SC: StarkGenericConfig,
        SC::Challenger: Clone,
        OpeningProof<SC>: Send + Sync,
        Com<SC>: Send + Sync,
        PcsProverData<SC>: Send + Sync,
        ShardMainData<SC>: Serialize + DeserializeOwned,
        SC::Val: p3_field::PrimeField32,
    {
        let mut challenger = config.challenger();
        let machine = RiscvAir::machine(config);

        let (_, vk) = machine.setup(&Program::from(elf));
        machine.verify(&vk, &proof.proof, &mut challenger)
    }
}

impl<SC: StarkGenericConfig + Serialize + DeserializeOwned> SP1ProofWithIO<SC> {
    /// Saves the proof as a JSON to the given path.
    pub fn save(&self, path: &str) -> Result<()> {
        let data = serde_json::to_string(self).unwrap();
        fs::write(path, data).unwrap();
        Ok(())
    }
}
